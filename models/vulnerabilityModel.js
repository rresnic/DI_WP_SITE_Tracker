const {db} = require("../config/db.js");
const axios = require('axios');

module.exports = {
    createVulnerability: async (software_name, affected_versions, severity, description, reference_url, reported_date, last_updated, patch_available, wf_id) => {
        const trx = await db.transaction();
        try {
            const [vulnerability] = await trx("vulnerabilities").insert(
                    {
                        software_name: software_name.toLowerCase(),
                        affected_versions,
                        severity,
                        description,
                        reference_url,
                        reported_date,
                        last_updated,
                        patch_available,
                        wf_id
                    }, 
                    ["software_name", "affected_versions", "severity", "description", "reference_url", "reported_date", "last_updated", "patch_available", "wf_id"]
                )
            await trx.commit();
            return vulnerability;
        } catch (error) {
            await trx.rollback();
            console.log("error adding vulnetability: ", error);
            throw(error);
        }
    },
    dropAndImport: async () =>{
        const trx = await db.transaction();
        try {
          // Fetch data from Wordfence API
          const response = await axios.get('https://www.wordfence.com/api/intelligence/v2/vulnerabilities/production');
          const vulnerabilities = Object.values(response.data)
          // Truncate the vulnerabilities table and reset the primary key
          await trx('vulnerabilities').truncate();
          await trx.raw('ALTER SEQUENCE vulnerabilities_vulnerability_id_seq RESTART WITH 1');
    
          // Insert new data into the vulnerabilities table
          for (const vulnerability of vulnerabilities) {
            console.log(              
                    "software_name", vulnerability.software[0].name.toLowerCase(),
                    "affected_versions", Object.keys(vulnerability.software[0].affected_versions).join(', '),
                    "severity", vulnerability.cvss.rating,
                    "description", vulnerability.title,
                    "reference_url", vulnerability.references[0],
                    "reported_date", new Date(vulnerability.published).toISOString(),
                    "last_updated", new Date(vulnerability.updated).toISOString(),
                    "patch_available", vulnerability.software[0].patched ? 'Yes' : 'No',
                    "wf_id", vulnerability.id,);
            await trx('vulnerabilities').insert({
              software_name: vulnerability.software[0].name.toLowerCase(),
              affected_versions: Object.keys(vulnerability.software[0].affected_versions).join(', '),
              severity: vulnerability.cvss.rating,
              description: vulnerability.title,
              reference_url: vulnerability.references[0],
              reported_date: new Date(vulnerability.published).toISOString(),
              last_updated: new Date(vulnerability.updated).toISOString(),
              patch_available: vulnerability.software[0].patched ? 'Yes' : 'No',
              wf_id: vulnerability.id,
            });
          }
    
          await trx.commit();
          console.log('Vulnerabilities table has been truncated and updated successfully.');
          return true;
        } catch (error) {
          await trx.rollback();
          console.error('Error updating vulnerabilities table:', error);
          throw error;
        }
    },
    getAllVulnerabilities: async () => {
        try {
            const vulnerabilities = await db("vulnerabilities").select(
                ["software_name", "affected_versions", "severity", "description", "reference_url", "reported_date", "last_updated", "patch_available", "wf_id"]
            );
            return vulnerabilities;
        } catch (error) {
            console.log(error);
            throw error;
        }
    },
    getUserRelevantVulnerabilities: async (user_id) => {

        try {
            const softwareNames = await db('website_software')
                .join('user_websites', 'website_software.website_id', '=', 'user_websites.uw_id')
                .where('user_websites.user_id', user_id)
                .select('website_software.name')
                .distinct();

            const softwareNamesArray = softwareNames.map(software => software.name.toLowerCase());

            const vulnerabilities = await db('vulnerabilities')
                .whereIn('software_name', softwareNamesArray)
                .select(
                    'software_name',
                    'affected_versions',
                    'severity',
                    'description',
                    'reference_url',
                    'reported_date',
                    'last_updated',
                    'patch_available',
                    'wf_id'
                );

            return vulnerabilities;
        } catch (error) {
            console.error("Error retrieving relevant vulnerabilities:", error);
            throw error;
        }
    },
}